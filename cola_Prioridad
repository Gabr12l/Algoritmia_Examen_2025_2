#include <iostream>
#include "Cola.h"
#include "funcionesCola.h"
using namespace std;

void construir(struct Cola & colaTAD){
    colaTAD.inicio = nullptr;
    colaTAD.prioridad = nullptr;
    colaTAD.fin = nullptr;
    colaTAD.longitud = 0;
}

/*devuelve la longitud de la cola*/
int longitud(const struct Cola & colaTAD) {
    return colaTAD.longitud;
}

void encolar(struct Cola &colaTAD, const struct ElementoCola & elemento){
    struct NodoCola *nuevo;
    nuevo = new NodoCola{};
    nuevo->elemento = elemento;
    if(esColaVacia(colaTAD)){
        colaTAD.inicio = nuevo;
        colaTAD.fin = nuevo;
    }
    else {
        colaTAD.fin->siguiente = nuevo;
        colaTAD.fin = nuevo;
    }
    colaTAD.longitud++;
}
void encolarPrioridad(struct Cola &cola, const struct ElementoCola & elemento) {
    struct NodoCola *nuevo;
    nuevo = new NodoCola{};
    nuevo->elemento = elemento;
    if (esColaVacia(cola)) {
        cola.inicio = nuevo;
        cola.fin = nuevo;
        if (elemento.prioridad =='V') {
            cola.prioridad = nuevo;
        }
    }else {
        if (elemento.prioridad =='V') {
            //para este caso la prioridad a considera para el manejo de la inserccion es el V
            if (cola.prioridad == nullptr) {
                nuevo->siguiente= cola.inicio; //apunta al primer A
                cola.inicio = nuevo;
                cola.prioridad = nuevo;
            }else {
                if (cola.prioridad->siguiente == nullptr) {
                    cola.fin = nuevo;
                }else {
                    nuevo->siguiente = cola.prioridad->siguiente;//para no perder el nuevo A
                }
                cola.prioridad->siguiente = nuevo;
                cola.prioridad = nuevo;
            }
        }else {
            cola.fin->siguiente = nuevo;
            cola.fin = nuevo;
        }
    }
}

struct ElementoCola desencolar(struct Cola & colaTAD){
    struct NodoCola * pSale;
    struct ElementoCola elemento;
    pSale = colaTAD.inicio;
    colaTAD.inicio = colaTAD.inicio->siguiente;
    elemento = pSale->elemento;
    colaTAD.longitud--;
    delete pSale;
    return elemento;
}

bool esColaVacia(const struct Cola & colaTAD){
    return colaTAD.inicio == nullptr;
}

void imprimir(const struct Cola & colaTAD) {
    if (esColaVacia(colaTAD)) {
        cout << "La cola esta vacia no se puede mostrar" << endl;
    } else {
        struct NodoCola * recorrido = colaTAD.inicio;
        int estaImprimiendoLaCabeza = 1;
        cout << "[";

        while (recorrido != nullptr) {
            /*Este artificio coloca las comas despues del inicio*/
            if ( not estaImprimiendoLaCabeza)
                cout << ", ";
            estaImprimiendoLaCabeza = 0;
            cout << recorrido->elemento.codigo<<" "<<recorrido->elemento.prioridad<<" ";
            recorrido = recorrido->siguiente;
        }
        cout << "]" << endl;
    }
}

3 prioridades


#include "Cola.h"
#include <iostream>
using namespace std;

void encolarPrioridad(struct Cola &cola, const struct ElementoCola &elemento) {
    NodoCola *nuevo = new NodoCola{};
    nuevo->elemento = elemento;
    nuevo->siguiente = nullptr;

    if (cola.inicio == nullptr) {
        // Si la cola estÃ¡ vacÃ­a
        cola.inicio = cola.fin = nuevo;
        if (elemento.prioridad == 'R') cola.priAlta = nuevo;
        else if (elemento.prioridad == 'A') cola.priMedia = nuevo;
        cola.longitud++;
        return;
    }

    // ðŸ”´ CASO 1: prioridad Alta (R)
    if (elemento.prioridad == 'R') {
        if (cola.priAlta == nullptr) {
            // No hay 'R' aÃºn: insertar al inicio
            nuevo->siguiente = cola.inicio;
            cola.inicio = nuevo;
        } else {
            // Insertar despuÃ©s del Ãºltimo 'R'
            nuevo->siguiente = cola.priAlta->siguiente;
            cola.priAlta->siguiente = nuevo;
        }
        cola.priAlta = nuevo;
        // Si aÃºn no hay 'A', ajustar priMedia
        if (cola.priMedia == nullptr) cola.priMedia = cola.priAlta;
    }

    // ðŸŸ¡ CASO 2: prioridad Media (A)
    else if (elemento.prioridad == 'A') {
        if (cola.priMedia == nullptr) {
            // No hay 'A' aÃºn
            if (cola.priAlta != nullptr) {
                // Insertar despuÃ©s del Ãºltimo 'R'
                nuevo->siguiente = cola.priAlta->siguiente;
                cola.priAlta->siguiente = nuevo;
            } else {
                // No hay 'R' â†’ insertar al inicio
                nuevo->siguiente = cola.inicio;
                cola.inicio = nuevo;
            }
        } else {
            // Insertar despuÃ©s del Ãºltimo 'A'
            nuevo->siguiente = cola.priMedia->siguiente;
            cola.priMedia->siguiente = nuevo;
        }
        cola.priMedia = nuevo;
        if (nuevo->siguiente == nullptr) cola.fin = nuevo;
    }

    // ðŸŸ¢ CASO 3: prioridad Baja (V)
    else {
        cola.fin->siguiente = nuevo;
        cola.fin = nuevo;
    }

    cola.longitud++;
}



